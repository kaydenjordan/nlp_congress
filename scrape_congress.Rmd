---
title: "Scrape Congress"
author: "Erin M. Buchanan"
date: "3/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries

```{r}
library(rvest)
library(dplyr)
library(xml2)
library(stringr)
```

## Get List of Docs

```{r}
# example link
# "https://www.govinfo.gov/metadata/pkg/CREC-2022-03-16/mods.xml"

dates_pull <- seq(as.Date("2017-02-01"), as.Date("2017-03-01"), by="days")

dates_list <- list()

for (i in 1:length(dates_pull)){
  
  url <- paste0("https://www.govinfo.gov/metadata/pkg/CREC-", 
                dates_pull[i], 
                "/mods.xml")
  
  # try catch 
  read_congress <- function(url) {
    tryCatch( 
    { 
       example <- read_xml(url)
       error <- FALSE
      }, 
    error = function(e) { error <- TRUE } 
    )
  }
  
  results <- read_congress(url)
  
  if (!results) {
    
    example <- read_xml(url)  
    converted <- as_list(example)
    
    stuff <- converted$mods[grepl("relatedItem", names(converted$mods))]
    stuff <- unlist(stuff)
    df <- data.frame("name" = names(stuff), 
                     "part" = stuff)
    df <- subset(df, grepl(".htm$", part))
    df <- subset(df, grepl("PgS|PgH", part))
    
    df$where <- ifelse(
      grepl("PgS", df$part), "Senate", "House"
    )
    df$date <- as.character(dates_pull[i])
    
    dates_list[[i]] <- df
    
  }
  
  Sys.sleep(3)
  
}

df_full <- dplyr::bind_rows(dates_list)
```

## Data Clean Up

```{python}
# libraries
import requests
from bs4 import BeautifulSoup
import re
import time

# function to get the data
def get_text(url):
  # print(url)
  text = requests.get(url)
  clean_text = BeautifulSoup(text.content, "html.parser").get_text()
  clean_text = re.sub(r"{", "", clean_text)
  clean_text = re.sub(r"}", "", clean_text)
  clean_text = re.sub(r'\n', " ", clean_text)
  return clean_text

```


## Extract 

No want:
The SPEAKER pro tempore.
The ACTING PRESIDENT pro tempore.
Ms. DUCKWORTH thereupon assumed the Chair as Acting President pro tempore. 
The ACTING PRESIDENT pro tempore. The Senator from Minnesota. 
The PRESIDING OFFICER.

The clerk will call the roll.
The legislative clerk called the roll. [and what follows]

Do want:
Mr. SCHUMER.
Ms. BALDWIN.
Ms. GARCIA of Texas.
Mr. GOOD of Virginia.
Mrs. KIGGANS. 
Ms. JACKSON LEE.
Mr. AUSTIN SCOTT of Georgia.

Good example of full House record: https://www.govinfo.gov/content/pkg/CREC-2024-02-01/pdf/CREC-2024-02-01-house.pdf

Good example of full Senate record: https://www.govinfo.gov/content/pkg/CREC-2024-01-08/pdf/CREC-2024-01-08-senate.pdf
 
```{python}
# function to parse the data 
def get_starts(text):
  # name examples 
  # Mr. SCHUMER. Ms. BALDWIN.
  re_results = re.search(r'M[a-z]*\.\s[A-Z]*\.', text)
  # Ms. GARCIA of Texas. Mr. GOOD of Virginia.
  re_results2 = re.search(r'M[a-z]*\.\s[A-Z]*\sof\s[A-Z][a-z]*\.', text)
 
  # figure out if they both exist 
  if re_results: number_one = re_results.start()
  else: number_one = -1
  # figure out if they both exist 
  if re_results2: number_two = re_results2.start()
  else: number_two = -1
  
  # stop if none at all 
  if number_one < 0 and number_two < 0: return "None"
  # get the second if only one
  elif number_one < 0 and number_two >= 0: 
    name = text[re_results2.start():re_results2.end()]
    new_text = text[re_results2.end():]
    return [name, new_text, re_results2]
  # get the first if only one
  elif number_one >= 0 and number_two < 0: 
    name = text[re_results.start():re_results.end()]
    new_text = text[re_results.end():]
    return [name, new_text, re_results]
  # if more than one, grab that one first 
  elif number_one < number_two: 
    name = text[re_results.start():re_results.end()]
    new_text = text[re_results.end():]
    return [name, new_text, re_results] 
  # short results of people saying "sure"
  elif number_one == number_two:
    name = text[re_results.start():re_results.end()]
    new_text = text[re_results.end():]
  # if more than one, grab that one first 
  else: 
    name = text[re_results2.start():re_results2.end()]
    new_text = text[re_results2.end():]
    return [name, new_text, re_results2]

```

```{python}
# get the data
df_full = r.df_full

# get the information you need as a list
links = df_full['part'].to_list()
where = df_full['where'].to_list()
dates = df_full['date'].to_list()

# looping variable
i = 1426

# for every link the year 
for link in links[i:]:
  
  # get the text for that link 
  texts = get_text(link)
  #print(texts[0:100])
  #print("__\n")
  
  # then we would loop over each text  
  while texts:
    # so we would get starts
    try_one = get_starts(texts)
    
    # break if try_one is none
    if try_one == "None": break 
    
    # then we would test if the new text has one 
    try_two = get_starts(try_one[1])
    
    # test
    # print(try_one[2])
    # print("__\n")
    # print(try_two[2])
    # print("__\n")
    # print(texts[0:100])
    # print("-------------\n")
    
    # if no other stuff then save the shit 
    if try_two == 'None': 
      # append if they keep yapping 
      f = open(try_one[0] + where[i] + "." + dates[i] + '.txt', "a")  
      f.write(try_one[1])
      f.close()
      break 
    else: 
      f = open(try_one[0] + where[i] + "." + dates[i] + '.txt', "a") 
      # only print to the start of the next one
      f.write(try_one[1][:try_two[2].start()])
      # be sure to use start so you get the next name 
      texts = texts[try_two[2].start(): ]
      # loop back to the top 
  
  # reset i for the labels
  i = i + 1
  
  # take a small nap
  time.sleep(3)

```